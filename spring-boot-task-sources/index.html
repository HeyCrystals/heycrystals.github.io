<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.40.1" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>Spring Boot 任务task源码分析 &middot; 八一菜刀</title>

  
  <link type="text/css" rel="stylesheet" href="https://xiaoymin.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://xiaoymin.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://xiaoymin.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://xiaoymin.github.io/css/hyde.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://xiaoymin.github.io/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://xiaoymin.github.io/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="八一菜刀" />

  
</head>

  <body class=" ">
  <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://xiaoymin.github.io/"><h1>八一菜刀</h1></a>
      <p class="lead">
       顺着生命的河流一起流淌,体会身边的每份感动和感悟. 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="https://xiaoymin.github.io/">主页</a> </li>
      <li><a href="https://xiaoymin.github.io/blogs/"> 博客列表 </a></li><li><a href="https://xiaoymin.github.io/opensource/"> 开源软件 </a></li><li><a href="https://xiaoymin.github.io/softnews/"> 软件资讯 </a></li><li><a href="https://xiaoymin.github.io/about/"> 关于作者 </a></li>
    </ul>

    <p>&copy; 2018. All rights reserved. </p>
  </div>
</div>

    <div class="content container">
    <div class="post">
  <h1>Spring Boot 任务task源码分析</h1>
  <span class="post-date">2018-01-26</span>
  

<h2 id="enablescheduling注解">EnableScheduling注解</h2>

<p>在Spring Boot中添加任务job时,已提供很好的支持,只需在SpringBoot启动类加<code>@EnableScheduling</code>注解即可</p>

<p>如：</p>

<pre><code class="language-java">package com.lishiots.lshui;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class ApiApplication {

	public static void main(String[] args) {
		SpringApplication.run(ApiApplication.class, args);
	}
}

</code></pre>

<p>EnableScheduling注解源码：</p>

<p>1、导入<code>SchedulingConfiguration</code>配置</p>

<p>2、注入<code>ScheduledAnnotationBeanPostProcessor</code>Bean实例</p>

<pre><code class="language-java">/*
 * Copyright 2002-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.scheduling.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.concurrent.Executor;

import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.scheduling.Trigger;
import org.springframework.scheduling.config.ScheduledTaskRegistrar;

/**
 * Enables Spring's scheduled task execution capability, similar to
 * functionality found in Spring's {@code &lt;task:*&gt;} XML namespace. To be used
 * on @{@link Configuration} classes as follows:
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * &amp;#064;Configuration
 * &amp;#064;EnableScheduling
 * public class AppConfig {
 *
 *     // various &amp;#064;Bean definitions
 * }&lt;/pre&gt;
 *
 * This enables detection of @{@link Scheduled} annotations on any Spring-managed
 * bean in the container. For example, given a class {@code MyTask}
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * package com.myco.tasks;
 *
 * public class MyTask {
 *
 *     &amp;#064;Scheduled(fixedRate=1000)
 *     public void work() {
 *         // task execution logic
 *     }
 * }&lt;/pre&gt;
 *
 * the following configuration would ensure that {@code MyTask.work()} is called
 * once every 1000 ms:
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * &amp;#064;Configuration
 * &amp;#064;EnableScheduling
 * public class AppConfig {
 *
 *     &amp;#064;Bean
 *     public MyTask task() {
 *         return new MyTask();
 *     }
 * }&lt;/pre&gt;
 *
 * Alternatively, if {@code MyTask} were annotated with {@code @Component}, the
 * following configuration would ensure that its {@code @Scheduled} method is
 * invoked at the desired interval:
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * &amp;#064;Configuration
 * &amp;#064;EnableScheduling
 * &amp;#064;ComponentScan(basePackages=&quot;com.myco.tasks&quot;)
 * public class AppConfig {
 * }&lt;/pre&gt;
 *
 * Methods annotated with {@code @Scheduled} may even be declared directly within
 * {@code @Configuration} classes:
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * &amp;#064;Configuration
 * &amp;#064;EnableScheduling
 * public class AppConfig {
 *
 *     &amp;#064;Scheduled(fixedRate=1000)
 *     public void work() {
 *         // task execution logic
 *     }
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;By default, will be searching for an associated scheduler definition: either
 * a unique {@link org.springframework.scheduling.TaskScheduler} bean in the context,
 * or a {@code TaskScheduler} bean named &quot;taskScheduler&quot; otherwise; the same lookup
 * will also be performed for a {@link java.util.concurrent.ScheduledExecutorService}
 * bean. If neither of the two is resolvable, a local single-threaded default
 * scheduler will be created and used within the registrar.
 *
 * &lt;p&gt;When more control is desired, a {@code @Configuration} class may implement
 * {@link SchedulingConfigurer}. This allows access to the underlying
 * {@link ScheduledTaskRegistrar} instance. For example, the following example
 * demonstrates how to customize the {@link Executor} used to execute scheduled
 * tasks:
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * &amp;#064;Configuration
 * &amp;#064;EnableScheduling
 * public class AppConfig implements SchedulingConfigurer {
 *
 *     &amp;#064;Override
 *     public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
 *         taskRegistrar.setScheduler(taskExecutor());
 *     }
 *
 *     &amp;#064;Bean(destroyMethod=&quot;shutdown&quot;)
 *     public Executor taskExecutor() {
 *         return Executors.newScheduledThreadPool(100);
 *     }
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;Note in the example above the use of {@code @Bean(destroyMethod=&quot;shutdown&quot;)}.
 * This ensures that the task executor is properly shut down when the Spring
 * application context itself is closed.
 *
 * &lt;p&gt;Implementing {@code SchedulingConfigurer} also allows for fine-grained
 * control over task registration via the {@code ScheduledTaskRegistrar}.
 * For example, the following configures the execution of a particular bean
 * method per a custom {@code Trigger} implementation:
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * &amp;#064;Configuration
 * &amp;#064;EnableScheduling
 * public class AppConfig implements SchedulingConfigurer {
 *
 *     &amp;#064;Override
 *     public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
 *         taskRegistrar.setScheduler(taskScheduler());
 *         taskRegistrar.addTriggerTask(
 *             new Runnable() {
 *                 public void run() {
 *                     myTask().work();
 *                 }
 *             },
 *             new CustomTrigger()
 *         );
 *     }
 *
 *     &amp;#064;Bean(destroyMethod=&quot;shutdown&quot;)
 *     public Executor taskScheduler() {
 *         return Executors.newScheduledThreadPool(42);
 *     }
 *
 *     &amp;#064;Bean
 *     public MyTask myTask() {
 *         return new MyTask();
 *     }
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;For reference, the example above can be compared to the following Spring XML
 * configuration:
 *
 * &lt;pre class=&quot;code&quot;&gt;
 * {@code
 * &lt;beans&gt;
 *
 *     &lt;task:annotation-driven scheduler=&quot;taskScheduler&quot;/&gt;
 *
 *     &lt;task:scheduler id=&quot;taskScheduler&quot; pool-size=&quot;42&quot;/&gt;
 *
 *     &lt;task:scheduled-tasks scheduler=&quot;taskScheduler&quot;&gt;
 *         &lt;task:scheduled ref=&quot;myTask&quot; method=&quot;work&quot; fixed-rate=&quot;1000&quot;/&gt;
 *     &lt;/task:scheduled-tasks&gt;
 *
 *     &lt;bean id=&quot;myTask&quot; class=&quot;com.foo.MyTask&quot;/&gt;
 *
 * &lt;/beans&gt;
 * }&lt;/pre&gt;
 *
 * The examples are equivalent save that in XML a &lt;em&gt;fixed-rate&lt;/em&gt; period is used
 * instead of a custom &lt;em&gt;{@code Trigger}&lt;/em&gt; implementation; this is because the
 * {@code task:} namespace {@code scheduled} cannot easily expose such support. This is
 * but one demonstration how the code-based approach allows for maximum configurability
 * through direct access to actual componentry.&lt;p&gt;
 *
 * @author Chris Beams
 * @author Juergen Hoeller
 * @since 3.1
 * @see Scheduled
 * @see SchedulingConfiguration
 * @see SchedulingConfigurer
 * @see ScheduledTaskRegistrar
 * @see Trigger
 * @see ScheduledAnnotationBeanPostProcessor
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Import(SchedulingConfiguration.class)
@Documented
public @interface EnableScheduling {

}
</code></pre>

<p>##Scheduled注解</p>

<p>job类只需在方法上加<code>@Scheduled</code>注解即可,支持cron表达式</p>

<p>例如：</p>

<pre><code class="language-java">/***
 *
 * @since:screen-api 1.0
 * @author &lt;a href=&quot;mailto:xiaoymin@foxmail.com&quot;&gt;xiaoymin@foxmail.com&lt;/a&gt; 
 * 2018/01/22 13:44
 */
@Component
public class JgJob {

    private static final Logger logger = LoggerFactory.getLogger(JgJob.class);

    @Autowired
    JgService jgService;

    @Scheduled(cron = &quot;0 0/2 * * * ?&quot;)
    public void jgFlowJob(){
        logger.info(&quot;同步极光数据任务开始...&quot;);
        logger.info(new DateTime().toString(&quot;yyyy-MM-dd HH:mm:ss&quot;));
        String date=DateTime.now().toString(&quot;yyyyMMddHHmm&quot;);
        jgService.syncJgTouristFlow(date);
        logger.info(&quot;同步极光数据任务结束...&quot;);
    }
  
}
</code></pre>

<p>查看<code>Scheduled</code>注解源码：</p>

<ul>
<li>使用该注解标注的方法将会被执行，指定cron或者fxedDelay或者fixedRate属性</li>
<li>该注解标注必须无参数,如果有返回参数,将会被忽略</li>
<li>通过类<code>ScheduledAnnotationBeanPostProcessor</code>注入</li>
</ul>

<pre><code class="language-java">/**
 * An annotation that marks a method to be scheduled. Exactly one of
 * the {@link #cron()}, {@link #fixedDelay()}, or {@link #fixedRate()}
 * attributes must be specified.
 *
 * &lt;p&gt;The annotated method must expect no arguments. It will typically have
 * a {@code void} return type; if not, the returned value will be ignored
 * when called through the scheduler.
 *
 * &lt;p&gt;Processing of {@code @Scheduled} annotations is performed by
 * registering a {@link ScheduledAnnotationBeanPostProcessor}. This can be
 * done manually or, more conveniently, through the {@code &lt;task:annotation-driven/&gt;}
 * element or @{@link EnableScheduling} annotation.
 *
 * &lt;p&gt;This annotation may be used as a &lt;em&gt;meta-annotation&lt;/em&gt; to create custom
 * &lt;em&gt;composed annotations&lt;/em&gt; with attribute overrides.
 *
 * @author Mark Fisher
 * @author Dave Syer
 * @author Chris Beams
 * @since 3.0
 * @see EnableScheduling
 * @see ScheduledAnnotationBeanPostProcessor
 * @see Schedules
 */
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(Schedules.class)
public @interface Scheduled {
 .... 
}
</code></pre>

<p>##SchedulingConfiguration</p>

<pre><code class="language-java">/**
 * {@code @Configuration} class that registers a {@link ScheduledAnnotationBeanPostProcessor}
 * bean capable of processing Spring's @{@link Scheduled} annotation.
 *
 * &lt;p&gt;This configuration class is automatically imported when using the
 * {@link EnableScheduling @EnableScheduling} annotation. See
 * {@code @EnableScheduling}'s javadoc for complete usage details.
 *
 * @author Chris Beams
 * @since 3.1
 * @see EnableScheduling
 * @see ScheduledAnnotationBeanPostProcessor
 */
@Configuration
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
public class SchedulingConfiguration {

	@Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public ScheduledAnnotationBeanPostProcessor scheduledAnnotationProcessor() {
		return new ScheduledAnnotationBeanPostProcessor();
	}

}
</code></pre>

<h2 id="scheduledannotationbeanpostprocessor">ScheduledAnnotationBeanPostProcessor</h2>

<pre><code class="language-java">/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.scheduling.annotation;

import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Collections;
import java.util.IdentityHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.aop.support.AopUtils;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.ListableBeanFactory;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.NoUniqueBeanDefinitionException;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.beans.factory.config.AutowireCapableBeanFactory;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor;
import org.springframework.beans.factory.config.NamedBeanHolder;
import org.springframework.beans.factory.support.MergedBeanDefinitionPostProcessor;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationListener;
import org.springframework.context.EmbeddedValueResolverAware;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.core.MethodIntrospector;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.scheduling.Trigger;
import org.springframework.scheduling.config.CronTask;
import org.springframework.scheduling.config.IntervalTask;
import org.springframework.scheduling.config.ScheduledTask;
import org.springframework.scheduling.config.ScheduledTaskRegistrar;
import org.springframework.scheduling.support.CronTrigger;
import org.springframework.scheduling.support.ScheduledMethodRunnable;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;
import org.springframework.util.StringValueResolver;

/**
 * Bean post-processor that registers methods annotated with @{@link Scheduled}
 * to be invoked by a {@link org.springframework.scheduling.TaskScheduler} according
 * to the &quot;fixedRate&quot;, &quot;fixedDelay&quot;, or &quot;cron&quot; expression provided via the annotation.
 *
 * &lt;p&gt;This post-processor is automatically registered by Spring's
 * {@code &lt;task:annotation-driven&gt;} XML element, and also by the
 * {@link EnableScheduling @EnableScheduling} annotation.
 *
 * &lt;p&gt;Autodetects any {@link SchedulingConfigurer} instances in the container,
 * allowing for customization of the scheduler to be used or for fine-grained
 * control over task registration (e.g. registration of {@link Trigger} tasks.
 * See the @{@link EnableScheduling} javadocs for complete usage details.
 *
 * @author Mark Fisher
 * @author Juergen Hoeller
 * @author Chris Beams
 * @author Elizabeth Chatman
 * @since 3.0
 * @see Scheduled
 * @see EnableScheduling
 * @see SchedulingConfigurer
 * @see org.springframework.scheduling.TaskScheduler
 * @see org.springframework.scheduling.config.ScheduledTaskRegistrar
 * @see AsyncAnnotationBeanPostProcessor
 */
public class ScheduledAnnotationBeanPostProcessor
		implements MergedBeanDefinitionPostProcessor, DestructionAwareBeanPostProcessor,
		Ordered, EmbeddedValueResolverAware, BeanNameAware, BeanFactoryAware, ApplicationContextAware,
		SmartInitializingSingleton, ApplicationListener&lt;ContextRefreshedEvent&gt;, DisposableBean {

	/**
	 * The default name of the {@link TaskScheduler} bean to pick up: &quot;taskScheduler&quot;.
	 * &lt;p&gt;Note that the initial lookup happens by type; this is just the fallback
	 * in case of multiple scheduler beans found in the context.
	 * @since 4.2
	 */
	public static final String DEFAULT_TASK_SCHEDULER_BEAN_NAME = &quot;taskScheduler&quot;;


	protected final Log logger = LogFactory.getLog(getClass());

	private Object scheduler;

	private StringValueResolver embeddedValueResolver;

	private String beanName;

	private BeanFactory beanFactory;

	private ApplicationContext applicationContext;

	private final ScheduledTaskRegistrar registrar = new ScheduledTaskRegistrar();

	private final Set&lt;Class&lt;?&gt;&gt; nonAnnotatedClasses =
			Collections.newSetFromMap(new ConcurrentHashMap&lt;Class&lt;?&gt;, Boolean&gt;(64));

	private final Map&lt;Object, Set&lt;ScheduledTask&gt;&gt; scheduledTasks =
			new IdentityHashMap&lt;Object, Set&lt;ScheduledTask&gt;&gt;(16);


	@Override
	public int getOrder() {
		return LOWEST_PRECEDENCE;
	}

	/**
	 * Set the {@link org.springframework.scheduling.TaskScheduler} that will invoke
	 * the scheduled methods, or a {@link java.util.concurrent.ScheduledExecutorService}
	 * to be wrapped as a TaskScheduler.
	 * &lt;p&gt;If not specified, default scheduler resolution will apply: searching for a
	 * unique {@link TaskScheduler} bean in the context, or for a {@link TaskScheduler}
	 * bean named &quot;taskScheduler&quot; otherwise; the same lookup will also be performed for
	 * a {@link ScheduledExecutorService} bean. If neither of the two is resolvable,
	 * a local single-threaded default scheduler will be created within the registrar.
	 * @see #DEFAULT_TASK_SCHEDULER_BEAN_NAME
	 */
	public void setScheduler(Object scheduler) {
		this.scheduler = scheduler;
	}

	@Override
	public void setEmbeddedValueResolver(StringValueResolver resolver) {
		this.embeddedValueResolver = resolver;
	}

	@Override
	public void setBeanName(String beanName) {
		this.beanName = beanName;
	}

	/**
	 * Making a {@link BeanFactory} available is optional; if not set,
	 * {@link SchedulingConfigurer} beans won't get autodetected and
	 * a {@link #setScheduler scheduler} has to be explicitly configured.
	 */
	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
		this.beanFactory = beanFactory;
	}

	/**
	 * Setting an {@link ApplicationContext} is optional: If set, registered
	 * tasks will be activated in the {@link ContextRefreshedEvent} phase;
	 * if not set, it will happen at {@link #afterSingletonsInstantiated} time.
	 */
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) {
		this.applicationContext = applicationContext;
		if (this.beanFactory == null) {
			this.beanFactory = applicationContext;
		}
	}


	@Override
	public void afterSingletonsInstantiated() {
		// Remove resolved singleton classes from cache
		this.nonAnnotatedClasses.clear();

		if (this.applicationContext == null) {
			// Not running in an ApplicationContext -&gt; register tasks early...
			finishRegistration();
		}
	}

	@Override
	public void onApplicationEvent(ContextRefreshedEvent event) {
		if (event.getApplicationContext() == this.applicationContext) {
			// Running in an ApplicationContext -&gt; register tasks this late...
			// giving other ContextRefreshedEvent listeners a chance to perform
			// their work at the same time (e.g. Spring Batch's job registration).
			finishRegistration();
		}
	}

	private void finishRegistration() {
		if (this.scheduler != null) {
			this.registrar.setScheduler(this.scheduler);
		}

		if (this.beanFactory instanceof ListableBeanFactory) {
			Map&lt;String, SchedulingConfigurer&gt; configurers =
					((ListableBeanFactory) this.beanFactory).getBeansOfType(SchedulingConfigurer.class);
			for (SchedulingConfigurer configurer : configurers.values()) {
				configurer.configureTasks(this.registrar);
			}
		}

		if (this.registrar.hasTasks() &amp;&amp; this.registrar.getScheduler() == null) {
			Assert.state(this.beanFactory != null, &quot;BeanFactory must be set to find scheduler by type&quot;);
			try {
				// Search for TaskScheduler bean...
				this.registrar.setTaskScheduler(resolveSchedulerBean(TaskScheduler.class, false));
			}
			catch (NoUniqueBeanDefinitionException ex) {
				logger.debug(&quot;Could not find unique TaskScheduler bean&quot;, ex);
				try {
					this.registrar.setTaskScheduler(resolveSchedulerBean(TaskScheduler.class, true));
				}
				catch (NoSuchBeanDefinitionException ex2) {
					if (logger.isInfoEnabled()) {
						logger.info(&quot;More than one TaskScheduler bean exists within the context, and &quot; +
								&quot;none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' &quot; +
								&quot;(possibly as an alias); or implement the SchedulingConfigurer interface and call &quot; +
								&quot;ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: &quot; +
								ex.getBeanNamesFound());
					}
				}
			}
			catch (NoSuchBeanDefinitionException ex) {
				logger.debug(&quot;Could not find default TaskScheduler bean&quot;, ex);
				// Search for ScheduledExecutorService bean next...
				try {
					this.registrar.setScheduler(resolveSchedulerBean(ScheduledExecutorService.class, false));
				}
				catch (NoUniqueBeanDefinitionException ex2) {
					logger.debug(&quot;Could not find unique ScheduledExecutorService bean&quot;, ex2);
					try {
						this.registrar.setScheduler(resolveSchedulerBean(ScheduledExecutorService.class, true));
					}
					catch (NoSuchBeanDefinitionException ex3) {
						if (logger.isInfoEnabled()) {
							logger.info(&quot;More than one ScheduledExecutorService bean exists within the context, and &quot; +
									&quot;none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' &quot; +
									&quot;(possibly as an alias); or implement the SchedulingConfigurer interface and call &quot; +
									&quot;ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: &quot; +
									ex2.getBeanNamesFound());
						}
					}
				}
				catch (NoSuchBeanDefinitionException ex2) {
					logger.debug(&quot;Could not find default ScheduledExecutorService bean&quot;, ex2);
					// Giving up -&gt; falling back to default scheduler within the registrar...
					logger.info(&quot;No TaskScheduler/ScheduledExecutorService bean found for scheduled processing&quot;);
				}
			}
		}

		this.registrar.afterPropertiesSet();
	}

	private &lt;T&gt; T resolveSchedulerBean(Class&lt;T&gt; schedulerType, boolean byName) {
		if (byName) {
			T scheduler = this.beanFactory.getBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, schedulerType);
			if (this.beanFactory instanceof ConfigurableBeanFactory) {
				((ConfigurableBeanFactory) this.beanFactory).registerDependentBean(
						DEFAULT_TASK_SCHEDULER_BEAN_NAME, this.beanName);
			}
			return scheduler;
		}
		else if (this.beanFactory instanceof AutowireCapableBeanFactory) {
			NamedBeanHolder&lt;T&gt; holder = ((AutowireCapableBeanFactory) this.beanFactory).resolveNamedBean(schedulerType);
			if (this.beanFactory instanceof ConfigurableBeanFactory) {
				((ConfigurableBeanFactory) this.beanFactory).registerDependentBean(
						holder.getBeanName(), this.beanName);
			}
			return holder.getBeanInstance();
		}
		else {
			return this.beanFactory.getBean(schedulerType);
		}
	}


	@Override
	public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) {
	}

	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) {
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName) {
		Class&lt;?&gt; targetClass = AopUtils.getTargetClass(bean);
		if (!this.nonAnnotatedClasses.contains(targetClass)) {
			Map&lt;Method, Set&lt;Scheduled&gt;&gt; annotatedMethods = MethodIntrospector.selectMethods(targetClass,
					new MethodIntrospector.MetadataLookup&lt;Set&lt;Scheduled&gt;&gt;() {
						@Override
						public Set&lt;Scheduled&gt; inspect(Method method) {
							Set&lt;Scheduled&gt; scheduledMethods = AnnotatedElementUtils.getMergedRepeatableAnnotations(
									method, Scheduled.class, Schedules.class);
							return (!scheduledMethods.isEmpty() ? scheduledMethods : null);
						}
					});
			if (annotatedMethods.isEmpty()) {
				this.nonAnnotatedClasses.add(targetClass);
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;No @Scheduled annotations found on bean class: &quot; + bean.getClass());
				}
			}
			else {
				// Non-empty set of methods
				for (Map.Entry&lt;Method, Set&lt;Scheduled&gt;&gt; entry : annotatedMethods.entrySet()) {
					Method method = entry.getKey();
					for (Scheduled scheduled : entry.getValue()) {
						processScheduled(scheduled, method, bean);
					}
				}
				if (logger.isDebugEnabled()) {
					logger.debug(annotatedMethods.size() + &quot; @Scheduled methods processed on bean '&quot; + beanName +
							&quot;': &quot; + annotatedMethods);
				}
			}
		}
		return bean;
	}

	protected void processScheduled(Scheduled scheduled, Method method, Object bean) {
		try {
			Assert.isTrue(method.getParameterTypes().length == 0,
					&quot;Only no-arg methods may be annotated with @Scheduled&quot;);

			Method invocableMethod = AopUtils.selectInvocableMethod(method, bean.getClass());
			Runnable runnable = new ScheduledMethodRunnable(bean, invocableMethod);
			boolean processedSchedule = false;
			String errorMessage =
					&quot;Exactly one of the 'cron', 'fixedDelay(String)', or 'fixedRate(String)' attributes is required&quot;;

			Set&lt;ScheduledTask&gt; tasks = new LinkedHashSet&lt;ScheduledTask&gt;(4);

			// Determine initial delay
			long initialDelay = scheduled.initialDelay();
			String initialDelayString = scheduled.initialDelayString();
			if (StringUtils.hasText(initialDelayString)) {
				Assert.isTrue(initialDelay &lt; 0, &quot;Specify 'initialDelay' or 'initialDelayString', not both&quot;);
				if (this.embeddedValueResolver != null) {
					initialDelayString = this.embeddedValueResolver.resolveStringValue(initialDelayString);
				}
				try {
					initialDelay = Long.parseLong(initialDelayString);
				}
				catch (NumberFormatException ex) {
					throw new IllegalArgumentException(
							&quot;Invalid initialDelayString value \&quot;&quot; + initialDelayString + &quot;\&quot; - cannot parse into integer&quot;);
				}
			}

			// Check cron expression
			String cron = scheduled.cron();
			if (StringUtils.hasText(cron)) {
				Assert.isTrue(initialDelay == -1, &quot;'initialDelay' not supported for cron triggers&quot;);
				processedSchedule = true;
				String zone = scheduled.zone();
				if (this.embeddedValueResolver != null) {
					cron = this.embeddedValueResolver.resolveStringValue(cron);
					zone = this.embeddedValueResolver.resolveStringValue(zone);
				}
				TimeZone timeZone;
				if (StringUtils.hasText(zone)) {
					timeZone = StringUtils.parseTimeZoneString(zone);
				}
				else {
					timeZone = TimeZone.getDefault();
				}
				tasks.add(this.registrar.scheduleCronTask(new CronTask(runnable, new CronTrigger(cron, timeZone))));
			}

			// At this point we don't need to differentiate between initial delay set or not anymore
			if (initialDelay &lt; 0) {
				initialDelay = 0;
			}

			// Check fixed delay
			long fixedDelay = scheduled.fixedDelay();
			if (fixedDelay &gt;= 0) {
				Assert.isTrue(!processedSchedule, errorMessage);
				processedSchedule = true;
				tasks.add(this.registrar.scheduleFixedDelayTask(new IntervalTask(runnable, fixedDelay, initialDelay)));
			}
			String fixedDelayString = scheduled.fixedDelayString();
			if (StringUtils.hasText(fixedDelayString)) {
				Assert.isTrue(!processedSchedule, errorMessage);
				processedSchedule = true;
				if (this.embeddedValueResolver != null) {
					fixedDelayString = this.embeddedValueResolver.resolveStringValue(fixedDelayString);
				}
				try {
					fixedDelay = Long.parseLong(fixedDelayString);
				}
				catch (NumberFormatException ex) {
					throw new IllegalArgumentException(
							&quot;Invalid fixedDelayString value \&quot;&quot; + fixedDelayString + &quot;\&quot; - cannot parse into integer&quot;);
				}
				tasks.add(this.registrar.scheduleFixedDelayTask(new IntervalTask(runnable, fixedDelay, initialDelay)));
			}

			// Check fixed rate
			long fixedRate = scheduled.fixedRate();
			if (fixedRate &gt;= 0) {
				Assert.isTrue(!processedSchedule, errorMessage);
				processedSchedule = true;
				tasks.add(this.registrar.scheduleFixedRateTask(new IntervalTask(runnable, fixedRate, initialDelay)));
			}
			String fixedRateString = scheduled.fixedRateString();
			if (StringUtils.hasText(fixedRateString)) {
				Assert.isTrue(!processedSchedule, errorMessage);
				processedSchedule = true;
				if (this.embeddedValueResolver != null) {
					fixedRateString = this.embeddedValueResolver.resolveStringValue(fixedRateString);
				}
				try {
					fixedRate = Long.parseLong(fixedRateString);
				}
				catch (NumberFormatException ex) {
					throw new IllegalArgumentException(
							&quot;Invalid fixedRateString value \&quot;&quot; + fixedRateString + &quot;\&quot; - cannot parse into integer&quot;);
				}
				tasks.add(this.registrar.scheduleFixedRateTask(new IntervalTask(runnable, fixedRate, initialDelay)));
			}

			// Check whether we had any attribute set
			Assert.isTrue(processedSchedule, errorMessage);

			// Finally register the scheduled tasks
			synchronized (this.scheduledTasks) {
				Set&lt;ScheduledTask&gt; registeredTasks = this.scheduledTasks.get(bean);
				if (registeredTasks == null) {
					registeredTasks = new LinkedHashSet&lt;ScheduledTask&gt;(4);
					this.scheduledTasks.put(bean, registeredTasks);
				}
				registeredTasks.addAll(tasks);
			}
		}
		catch (IllegalArgumentException ex) {
			throw new IllegalStateException(
					&quot;Encountered invalid @Scheduled method '&quot; + method.getName() + &quot;': &quot; + ex.getMessage());
		}
	}


	@Override
	public void postProcessBeforeDestruction(Object bean, String beanName) {
		Set&lt;ScheduledTask&gt; tasks;
		synchronized (this.scheduledTasks) {
			tasks = this.scheduledTasks.remove(bean);
		}
		if (tasks != null) {
			for (ScheduledTask task : tasks) {
				task.cancel();
			}
		}
	}

	@Override
	public boolean requiresDestruction(Object bean) {
		synchronized (this.scheduledTasks) {
			return this.scheduledTasks.containsKey(bean);
		}
	}

	@Override
	public void destroy() {
		synchronized (this.scheduledTasks) {
			Collection&lt;Set&lt;ScheduledTask&gt;&gt; allTasks = this.scheduledTasks.values();
			for (Set&lt;ScheduledTask&gt; tasks : allTasks) {
				for (ScheduledTask task : tasks) {
					task.cancel();
				}
			}
			this.scheduledTasks.clear();
		}
		this.registrar.destroy();
	}

}

</code></pre>

<h2 id="scheduledmethodrunnable">ScheduledMethodRunnable</h2>

<p>任务执行方法,主要包括两个属性：</p>

<blockquote>
<p>target&ndash;&gt; Spring 容器 bean实例</p>

<p>method &ndash;&gt; Bean对象方法</p>
</blockquote>

<p>源码：</p>

<pre><code class="language-java">/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.scheduling.support;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.UndeclaredThrowableException;

import org.springframework.util.ReflectionUtils;

/**
 * Variant of {@link MethodInvokingRunnable} meant to be used for processing
 * of no-arg scheduled methods. Propagates user exceptions to the caller,
 * assuming that an error strategy for Runnables is in place.
 *
 * @author Juergen Hoeller
 * @since 3.0.6
 * @see org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor
 */
public class ScheduledMethodRunnable implements Runnable {

	private final Object target;

	private final Method method;


	public ScheduledMethodRunnable(Object target, Method method) {
		this.target = target;
		this.method = method;
	}

	public ScheduledMethodRunnable(Object target, String methodName) throws NoSuchMethodException {
		this.target = target;
		this.method = target.getClass().getMethod(methodName);
	}


	public Object getTarget() {
		return this.target;
	}

	public Method getMethod() {
		return this.method;
	}


	@Override
	public void run() {
		try {
			ReflectionUtils.makeAccessible(this.method);
			this.method.invoke(this.target);
		}
		catch (InvocationTargetException ex) {
			ReflectionUtils.rethrowRuntimeException(ex.getTargetException());
		}
		catch (IllegalAccessException ex) {
			throw new UndeclaredThrowableException(ex);
		}
	}

}

</code></pre>

</div>


    </div>

    
  </body>
</html>